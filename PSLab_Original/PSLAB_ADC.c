/******************************************************************************/
/******** This file contains ADC control modules of function.c file ***********/
/******************************************************************************/
#include "COMMANDS.h"
#include "Common_Functions.h"
#include "PSLAB_SPI.h"
#include "PSLAB_ADC.h"

BYTE CHOSA = 3;
BYTE CH123SA = 0;
BYTE conversion_done = 1;
BYTE TRIGGERED = 0;
BYTE TRIGGER_READY = 0;
BYTE TRIGGER_CHANNEL = 0;
BYTE ADC_CHANNELS = 0;
uint16 TRIGGER_TIMEOUT = 100, TRIGGER_WAITING = 0, TRIGGER_LEVEL = 0, TRIGGER_PRESCALER = 0;
uint16 adval;
uint16 ADC_DELAY = 5;
int *buff0, *buff1, *buff2, *buff3;
int samples = 0;
uint16 samples_to_fetch = BUFFER_SIZE;

int __attribute__((section("adcbuff"), far)) ADCbuffer[BUFFER_SIZE];

void __attribute__((interrupt, no_auto_psv)) _AD1Interrupt(void) {
    _AD1IF = 0;
    if (conversion_done) {
        return;
    }
    LEDPIN = 1;
    if (TRIGGERED) {
        *(buff0++) = (ADC1BUF0); //&0x3ff;
        if (ADC_CHANNELS >= 1) {
            *(buff1++) = (ADC1BUF1); //&0x3ff;
            if (ADC_CHANNELS >= 2) {
                *buff2++ = (ADC1BUF2); //&0x3ff;
                if (ADC_CHANNELS >= 3)*buff3++ = (ADC1BUF3); //&0x3ff;
            }
        }
        samples++;
        LEDPIN = 0;
        if (samples == samples_to_fetch) {
            _AD1IF = 0;
            _AD1IE = 0; //disable any further interrupts until required
            conversion_done = 1;
            LEDPIN = 1;
        }
    } else {
        if (TRIGGER_CHANNEL & 1)adval = ADC1BUF0;
        else if (TRIGGER_CHANNEL & 2)adval = ADC1BUF1;
        else if (TRIGGER_CHANNEL & 4)adval = ADC1BUF2;
        else if (TRIGGER_CHANNEL & 8)adval = ADC1BUF3;

        //-------If the trigger hasn't timed out yet ... ----------
        if (TRIGGER_WAITING < TRIGGER_TIMEOUT) {
            TRIGGER_WAITING += (ADC_DELAY >> TRIGGER_PRESCALER);
            if (!TRIGGER_READY && adval > TRIGGER_LEVEL + 10)TRIGGER_READY = 1;
            else if (adval <= TRIGGER_LEVEL && TRIGGER_READY) {
                TRIGGERED = 1;
            }
        }            //-------If the trigger has timed out, then proceed to data acquisition ----------
        else {
            TRIGGERED = 1;
        }
    }

}

void initADCCTMU(void){
    _AD1IF = 0; _AD1IE = 0;                                             //disable ADC interrupts
    disableADCDMA();DisableComparator();
    AD1CON1bits.ADON = 0;                                               //turn off ADC
    AD1CON2 = 0;
    AD1CON4 = 0x0000;
    AD1CSSH = 0x0000;
    AD1CSSL = 0x0000;
    AD1CON1bits.AD12B = 1;
    /* Assign MUXA inputs for block read */
    AD1CHS0bits.CH0SA = CHOSA;
    AD1CON3bits.ADRC = 0; //do not use internal clock
    AD1CON1bits.SSRCG = 0;
    AD1CON1bits.SSRC = 0b000; //Clearing SAMP bit stops sampling and triggers conversion
    AD1CON1bits.SIMSAM = 0; //simultaneous sampling.
    AD1CON1bits.ASAM = 0; //no auto sampling
    AD1CON3bits.SAMC = 0x10; // Sample for (x+1)*Tad before triggering conversion
    AD1CON2bits.SMPI = 0;
    AD1CON3bits.ADCS = 0xA; // Conversion clock x*Tp
    
}

void DisableComparator() {
    CM4CONbits.CON = 0;
    PMD3bits.CMPMD = 1;
}

void EnableComparator() {
    /*----setup comparator---*/
    CVRCONbits.VREFSEL = 0; // Voltage reference is generated by resistor network
    CVRCONbits.CVREN = 1; // Enable comparator reference source
    CVRCONbits.CVRR = 0; // Step size is CVRSRC/32
    CVRCONbits.CVR = 7; // CVREFIN = (1/4)*(3.3) + (7/32)*(3.3) = 1.54V

    CM4CONbits.CCH = 0; // VIN - input of comparator connects to C4IN1-
    CM4CONbits.CREF = 1; // VIN+ input connected to CVRefin voltage source
    CM4CONbits.EVPOL = 1; // Trigger/Event/Interrupt generated on high to low
    CM4CONbits.CPOL = 0; // Comparator output is not inverted
    CM4CONbits.CEVT = 0;
    CM4CONbits.COE = 1; // Comparator output is present on CxOUT pin
    CM4FLTRbits.CFSEL = 0; // Choose CPU instruction clock (TCY)
    CM4FLTRbits.CFDIV = 4; // Choose comparator filter clock
    CM4FLTRbits.CFLTREN = 1; // Digital filter enabled
    CM4MSKSRCbits.SELSRCA = 1; // PWM1H1 is the source for Mask A input
    CM4MSKCONbits.HLMS = 1; // Mask input will prevent comparator output
    CM4MSKCONbits.OAEN = 1; // OR Gate A input enabled
    CM4CONbits.CON = 1; // Comparator is enabled
    PMD3bits.CMPMD = 0; // Enable Comparator
}

void initADC10(void) {
    /* Set port configuration */
    AD1CON1 = 0;
    disableADCDMA();
    /* Initialize ADC module */
    AD1CON1bits.AD12B = 0;
    AD1CON1bits.SSRCG = 0;
    AD1CON1bits.SSRC = 4; //Timer5 compare starts conversion
    AD1CON1bits.ASAM = 1; //auto sampling

    AD1CON1bits.SIMSAM = 1; //simultaneous sampling
    AD1CHS0bits.CH0SA = CHOSA; //AN3 - CH0
    AD1CHS0bits.CH0NA = 0;
    AD1CHS123bits.CH123SA = CH123SA; //AN0 -> CH1 , AN1 -> ch2, AN2 -> ch3
    AD1CHS123bits.CH123NA = 0; //-ve of CH1,2,3 to -vref
    AD1CON2bits.SMPI = 0; //generate interrupt after converting all chans

    AD1CON4 = 0x0000;
    AD1CSSH = 0x0000;
    AD1CSSL = 0x0000;

    /* Assign MUXA inputs for block read */
    _AD1IF = 0;
    _AD1IE = 0; //disable ADC interrupt until required
    //AD1CON3bits.SAMC = 0; // SAMC - Sample for (x+1)*Tad before triggering conversion (TMR5 will decide this here)
    AD1CON3bits.ADCS = 1; // Conversion clock x*Tp
    AD1CON3bits.ADRC = 0; //use clock derived from system clock

    AD1CON1bits.ADON = 1;
    Delay_us(20);

    T5CONbits.TON = 0;
    T5CONbits.TSIDL = 1;
    T5CONbits.TCKPS = 1;
    TMR5 = 0x0000;
    T5CONbits.TON = 1;
    _T5IF = 0;
    _T5IE = 0;
}

void initADCDMA(BYTE bits) {
    /* Set port configuration */
    AD1CON1 = 0;
    /* Initialize ADC module */
    AD1CON1bits.AD12B = bits;
    AD1CON1bits.SSRCG = 0;
    AD1CON1bits.SSRC = 4; //Timer5 compare starts conversion
    AD1CON1bits.ASAM = 1; //auto sampling

    AD1CON1bits.SIMSAM = 1; //simultaneous sampling
    AD1CHS0bits.CH0SA = CHOSA;
    AD1CHS0bits.CH0NA = 0;
    AD1CHS123bits.CH123SA = CH123SA; //AN0 -> CH1 , AN1 -> ch2, AN2 -> ch3
    AD1CHS123bits.CH123NA = 0; //-ve of CH1,2,3 to -vref
    AD1CON2bits.SMPI = 0; //generate interrupt after converting all chans

    AD1CON4 = 0x0000;
    AD1CSSH = 0x0000;
    AD1CSSL = 0x0000;

    /* Assign MUXA inputs for block read */
    _AD1IF = 0;
    _AD1IE = 0; //disable ADC interrupt until required
    AD1CON3bits.ADCS = 1; // Conversion clock x*Tp
    AD1CON3bits.ADRC = 0; //use clock derived from system clock

    AD1CON1bits.ADON = 1;
    Delay_us(20);

    T5CONbits.TON = 0;
    T5CONbits.TSIDL = 1;
    T5CONbits.TCKPS = 1;
    TMR5 = 0x0000;
    _T5IF = 0;
    _T5IE = 0;

    DMA0CONbits.CHEN = 0;

    DMA0CONbits.AMODE = 0b00; // Register indirect with post increment
    DMA0CONbits.MODE = 0b01; // One Shot, Ping-Pong mode Disabled
    DMA0CONbits.DIR = 0; // Peripheral to RAM
    DMA0REQ = 0b1101; // Select ADC module as DMA request source


    DMA_MODE = DMA_LA_ONE_CHAN;
    enableADCDMA();

}

void initADC12bit_scope(void) {
    /* Set port configuration */
    disableADCDMA();

    AD1CON1bits.ADON = 0;
    /* Initialize ADC module */
    AD1CON1bits.AD12B = 1;
    AD1CON1bits.SSRCG = 0;
    AD1CON1bits.SSRC = 4; //Timer5 compare starts conversion
    AD1CON1bits.ASAM = 1; //auto sampling

    AD1CHS0bits.CH0SA = CHOSA; //AN3 - CH0
    AD1CHS0bits.CH0NA = 0;
    AD1CON2bits.SMPI = 0; //generate interrupt after converting all chans

    AD1CON4 = 0x0000;
    AD1CSSH = 0x0000;
    AD1CSSL = 0x0000;

    /* Assign MUXA inputs for block read */
    _AD1IF = 0;
    _AD1IE = 0; //disable ADC interrupt until required
    AD1CON3bits.ADCS = 9; // Conversion clock x*Tp
    AD1CON3bits.ADRC = 0; //use clock derived from system clock

    AD1CON1bits.ADON = 1;
    Delay_us(20);

    T5CONbits.TON = 0;
    T5CONbits.TSIDL = 1;
    T5CONbits.TCKPS = 1;
    TMR5 = 0x0000;
    T5CONbits.TON = 1;
    _T5IF = 0;
    _T5IE = 0;
}

void initADC12(void) {
    _AD1IF = 0;
    _AD1IE = 0;
    disableADCDMA();

    AD1CON2 = 0;
    AD1CON4 = 0x0000;
    AD1CSSH = 0x0000;
    AD1CSSL = 0x0000;

    AD1CON1bits.ADON = 0;

    AD1CON1bits.AD12B = 1;
    AD1CON1bits.ADSIDL = 0;
    AD1CON3bits.ADRC = 1; //use internal clock
    AD1CON1bits.SSRCG = 0;
    AD1CON2bits.CHPS = 0;
    AD1CHS0bits.CH0SA = CHOSA; //AN3 - CH0
    AD1CHS0bits.CH0NA = 0;
    AD1CON1bits.SSRC = 7; //Internal counter ends sampling, starts conversion
    //AD1CON1bits.SIMSAM = 0; //simultaneous sampling  .  Not applicable for single channel sampling
    AD1CON1bits.ASAM = 0; // No auto sampling
    AD1CON2bits.SMPI = 0; //generate interrupt after argument+1 conversion

    /* Assign MUXA inputs for block read */
    //AD1CHS0bits.CH0SA = channel; //AN<channel> connected to CH0
    AD1CON3bits.SAMC = 0x1f; // Sample for (x+1)*Tad before triggering conversion
    AD1CON3bits.ADCS = 9; // Conversion clock x*Tp

    //AD1CON2bits.CHPS = 0; //unimplemented in 12 bit mode. read as 0
    AD1CON1bits.ADON = 1;
    Delay_us(20);
}

void initADC12_averaging16() {
    _AD1IF = 0;
    _AD1IE = 0; //disable ADC interrupts
    disableADCDMA();

    AD1CON1bits.ADON = 0; //turn off ADC.
    AD1CON2 = 0;
    AD1CON4 = 0x0000;
    AD1CSSH = 0x0000;
    AD1CSSL = 0x0000;
    AD1CON1bits.AD12B = 1; //12 bit mode
    AD1CON1bits.ADSIDL = 0; //continue operation in idle
    AD1CON3bits.ADRC = 0; //do not use internal clock
    AD1CON1bits.SSRCG = 0;
    AD1CON2bits.CHPS = 0;
    /* Assign MUXA inputs for block read */
    AD1CHS0bits.CH0SA = CHOSA;
    AD1CHS0bits.CH0NA = 0;
    AD1CON1bits.SSRC = 7; //Internal counter ends sampling, starts conversion (SSRCG=0)

    AD1CON3bits.SAMC = 0x10; // Sample for (x+1)*Tad before triggering conversion
    AD1CON3bits.ADCS = 0xA; // Conversion clock Tad = ADCS*Tp(15nS))
    AD1CON2bits.SMPI = 15; //generate interrupt after argument+1 conversions
}

void setADCMode(BYTE mode, BYTE chosa, BYTE ch123sa) {
    if (ADC_MODE == mode && chosa == CHOSA && ch123sa == CH123SA)return;
    else {
        if (CHOSA == 7 || CHOSA == 5)DisableComparator();
        ADC_MODE = mode;
        CHOSA = chosa;
        CH123SA = ch123sa;
        if (mode == ADC_10BIT_SIMULTANEOUS)initADC10();
        else if (mode == ADC_10BIT_DMA)initADCDMA(0); //12 bit mode disabled
        else if (mode == ADC_12BIT_DMA)initADCDMA(1); //12 bit mode
        else if (mode == ADC_12BIT)initADC12();
        else if (mode == ADC_12BIT_SCOPE)initADC12bit_scope();
        else if (mode == ADC_12BIT_AVERAGING)initADC12_averaging16();
        else if (mode == ADC_CTMU)initADCCTMU();


    }
}

uint16 get_voltage_summed(BYTE channel) {
    setADCMode(ADC_12BIT_AVERAGING, channel, 0);
    AD1CON1bits.ADON = 1;
    Delay_us(20); //Turn on the ADC
    AD1CON1bits.ASAM = 1; // auto sampling
    _AD1IF = 0;
    while (!_AD1IF);
    _AD1IF = 0;
    while (!AD1CON1bits.DONE); //wait for conversion
    AD1CON1bits.ASAM = 0; //stop auto sampling
    AD1CON1bits.ADON = 0;

    return (ADC1BUF0)+(ADC1BUF1)+(ADC1BUF2)+(ADC1BUF3)+(ADC1BUF4)+(ADC1BUF5)+(ADC1BUF6)+(ADC1BUF7)
            +(ADC1BUF8)+(ADC1BUF9)+(ADC1BUFA)+(ADC1BUFB)+(ADC1BUFC)+(ADC1BUFD)+(ADC1BUFE)+(ADC1BUFF);

}

uint16 get_voltage(BYTE channel) {
    AD1CHS0bits.CH0SA = channel; //AN<channel> connected to CH0
    AD1CON1bits.SAMP = 1; //start sampling
    while (!AD1CON1bits.DONE);
    return ADC1BUF0;
}

void setupADC10() {
    T5CONbits.TCKPS = 1;
    PR5 = ADC_DELAY - 1;
    TMR5 = 0x0000;
    T5CONbits.TON = 1;

}

void configureADC() {
    ANSELB = ANSELC = 0x0000;
    ANSELAbits.ANSA0 = 1; // Ensure AN0 is analog
    ANSELAbits.ANSA1 = 1; // Ensure AN1 is analog
    ANSELBbits.ANSB0 = 1;
    ANSELBbits.ANSB1 = 1;
    ANSELBbits.ANSB3 = 1;
    ANSELCbits.ANSC1 = 1;
    ANSELCbits.ANSC2 = 1; //URGENT!
}

void enableADCDMA() {
    AD1CON1bits.ADDMABM = 1;
    AD1CON4bits.ADDMAEN = 1;
}

void disableADCDMA() {
    AD1CON1bits.ADDMABM = 0;
    AD1CON4bits.ADDMAEN = 0;
    DMA0CONbits.CHEN = 0;
}
